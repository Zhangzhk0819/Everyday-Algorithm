## 5.5 快速排序
### 核心思想
1. 快速排序算法的计算复杂度非常低，只有O(nlgn)，其思想也非常巧妙，所以很值得学习。
2. 快排的核心思想是分治，首先选取一个参考值a，如果作升序排序，那么把比a小的值放在a左边，把比a大的值放在a右边，然后对a左边和右边序列再分别做快排，直到所有元素按升序排列。

### [程序实现](https://github.com/Zhangzhk0819/Everyday-Algorithm/blob/master/Code/Quicksort.cpp)
1. 整个程序框架使用递归算法。
2. 在每一步快排过程中，使用两个指针，分别指向数组首部和尾部，并把第一个元素作为参考值a，首先通过移动尾部指针，找到小于a的值，与a交换位置，然后通过移动首部指针，找到大于a的值，与a交换顺序，最后依次移动首尾指针，直到两个指针相遇，就完成了单步快排。

### 示例
假设数组 6 2 7 3 8 9  
1. 6 2 7 3 8 9  
2. 3 2 7 6 8 9  
3. 3 2 6 7 8 9  
4. 2 3 6 7 8 9

Reference:  
[百度百科](http://baike.baidu.com/link?url=QzOZlOqZFiPO82cpEOFH143ewPZdH7N1fS5ucXhjuYPL5Bxtan2ooV0gkPl9Dic2Lc3ggD6gjGA0sw1CsckQ2-TD9woGOxLozRGGGb3zLiJuN84xciMtAttZG-74C18_aXYiX_O0DT15XE_xzbdoOfK7VqvtMSObSiXX2O6oJIe2Z4Lv0JbiLbI5wejRGp_a)

## 5.6 如何判断单向链表是否存在环，并找出环的入口点
### 核心思想
1. 解决链表问题，一个非常有用的方法就是使用双指针，一个快指针，每次移动一步，一个指针慢，每次移动两步。
2. 判断是否存在环：让两个指针从头开始走，如果两个指针在某个时刻相遇了，那么说明链表存在环，否则快指针将会指向NULL。有一个问题是两个指针是否一定相遇，答案是肯定的，假设从链表头到环入口的距离是a，如果两指针会相遇，假设相遇点里环入口距离是b，那么慢指针走了a+b步，快指针走了a+b+nL步，其中L是环的长度，且a+b+nL=2(a+b)，所以nL=a+b，由于a和L为定值，我们总能找到一个b使得这个等式成立。
3. 如果存在环，寻找环的入口点的思路：两个指针相遇后，把其中一个指针移到链表头部，两个指针每次都只移动一步，那么两个指针第一次相遇那个点就是环的入口点。按照上面分析，两个指针相遇时nL=a+b。那么经过a+b步后，两个指针将再次相遇在b点相遇。由于两个指针都只移动一步，那么在b点的前一个点两点也是相遇的，向前反推，两点一点会在a点首次相遇。

Reference:  
[Jark's Blog](http://wuchong.me/blog/2014/03/25/interview-link-questions/)


## 5.7 堆排序
### 核心思想
1. 以下讨论若无特殊说明均为升序排序，堆顶元素最小。
2. 堆实际上是一种特殊的全二叉树结构，这个二叉树的父节点总小于或等于其子节点，这样一来，堆顶元素一定是最小元素。
3. 堆排序主要有两个步骤：首先对无序数组构建一个堆，那么堆顶元素既为最小值，记录这个最小值。然后对剩下的n-1个元素重新构建一个堆，这个重新构建的堆的堆顶元素就是次小的数，以此类推，直到整个堆只剩下两个数，真个排序结束。
4. 整个堆排序中有两个核心问题：首先，如何对无序数组构建一个堆，其次如何对剩下的n-1个元素重新构建一个堆，下面具体讨论。
5. 首先讨论如何对剩下n-1个元素重新构建一个堆，因为对无序数组构建一个堆其实重复使用了这个算法。用堆底元素把堆顶元素覆盖，这样一来破坏了原来的堆，所以接下来把堆顶元素与其较小的一个子节点交换位置，这样一来又破坏了该子节点的堆特性（注意，此时另外一个子节点的特性并没有改变），对其子节点继续重复该替换过程，直到形成一个新的堆。
6. 接下来讨论如何构建一个新的堆。构建新堆是从二叉树的倒数第二层开始的，依次对每个元素执行第5步的过程，这样一来倒数第二层以下都成为了堆。然后依次对倒数第三层执行第5步过程，使得倒数第三层也成为堆，知道执行到根节点。至此就构建了一个新堆。

Reference:  
[八大排序算法](http://blog.csdn.net/hguisu/article/details/7776068)  
[视觉直观感受 7 种常用的排序算法](http://blog.jobbole.com/11745/)

## 5.9 有序二维数组查找
### 问题描述
假设有一个n*n的有序数组，每一行元素从左到右都是升序排列，每一列元素从上到下都是升序排列。如何在小于O(n2)的时间复杂度内找到某个指定的数a？

### 解题思路
从右上角那个数m开始遍历，如果这个数大于a，那么可以把m所在的列全部去掉，如果m小于a，那么可以把m所在的行去掉。依次类推，最坏的情况下时间复杂度为O(n)。

Reference:  
剑指offer面试题3

## 5.12 重建二叉树
### 问题描述
根据二叉树前序遍历[1,2,4,7,3,5,6,8]和中序遍历[4,7,2,1,5,3,8,6]重构二叉树

### 二叉树遍历定义
![二叉树遍历](https://github.com/Zhangzhk0819/Everyday-Algorithm/blob/master/Figure/1.png)
[二叉树](http://blog.csdn.net/fansongy/article/details/6798278)

### 解题思路
主要掌握前序遍历和中序遍历的特点：  
1. 前序遍历：第一个节点为根节点。  
2. 中序遍历：根节点左边的所有点为其左子树节点，右边的所有点为其右子树节点。  
有了以上认识，可以通过递归的方式构建整个二叉树。注意，这个二叉树通过链表来存储。

Reference：  
剑指offer面试题6




